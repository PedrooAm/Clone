<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Our Blog on Deep Dives | Cloud training with a difference.</title>
    <link>https://enchanting-llama-faa0bb.netlify.app/blog/</link>
    <description>Recent content in Our Blog on Deep Dives | Cloud training with a difference.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 31 Aug 2020 20:33:11 +0600</lastBuildDate>
    
	<atom:link href="https://enchanting-llama-faa0bb.netlify.app/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AWS IAM Not*</title>
      <link>https://enchanting-llama-faa0bb.netlify.app/blog/aws-iam-not/</link>
      <pubDate>Sat, 02 Jan 2021 20:18:07 +0600</pubDate>
      
      <guid>https://enchanting-llama-faa0bb.netlify.app/blog/aws-iam-not/</guid>
      <description>Sometimes writing AWS IAM policies gets confusing. Especially if our policy authoring is reactive in nature instead of following a proactive permissions strategy.
Wow — this is complicated! Additionally some of the documentation and courseware suggest doing both allow and deny-statements.
What how?
Well the Amazon S3: Limits managing to a specific S3 Bucket example in the IAM User Guide shows the idea.
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;s3:*&amp;#34;, &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::bucket-name&amp;#34;, &amp;#34;arn:aws:s3:::bucket-name/*&amp;#34; ] }, { &amp;#34;Effect&amp;#34;: &amp;#34;Deny&amp;#34;, &amp;#34;NotAction&amp;#34;: &amp;#34;s3:*&amp;#34;, &amp;#34;NotResource&amp;#34;: [ &amp;#34;arn:aws:s3:::bucket-name&amp;#34;, &amp;#34;arn:aws:s3:::bucket-name/*&amp;#34; ] } ] } So here we’re allowing all S3 access on to a particular bucket and its contents, and then denying all other actions (for all other services!</description>
    </item>
    
    <item>
      <title>How to create a serverless URL shortener using Amazon S3</title>
      <link>https://enchanting-llama-faa0bb.netlify.app/blog/how-create-serverless-url-shortener-using-amazon-s3/</link>
      <pubDate>Mon, 06 Jan 2020 20:18:07 +0600</pubDate>
      
      <guid>https://enchanting-llama-faa0bb.netlify.app/blog/how-create-serverless-url-shortener-using-amazon-s3/</guid>
      <description>Let’s admit it. We access more and more of the information we need in our daily activities using URLs. These URLs have become longer and more cryptic over time but that’s ok since we simply click on them.
However, sometimes we need to communicate those URLs in a non-internset-native way. For me this has happened during training classes as well as when writing a book. I want the class to download a piece of source code, but the GitHub project file URL is way too long to be correctly retyped by the attendees.</description>
    </item>
    
  </channel>
</rss>